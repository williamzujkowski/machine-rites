#!/bin/bash

# tools/setup-doc-hooks.sh
# Setup pre-commit hooks for documentation updates
# Usage: ./tools/setup-doc-hooks.sh [--install|--uninstall] [--verbose]

set -euo pipefail

# Configuration
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"
GIT_HOOKS_DIR="$PROJECT_ROOT/.git/hooks"
VERBOSE=false
ACTION="install"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

show_help() {
    cat << EOF
Documentation Pre-commit Hooks Setup

USAGE:
    $0 [OPTIONS]

OPTIONS:
    --install           Install pre-commit hooks (default)
    --uninstall         Remove pre-commit hooks
    --verbose           Enable verbose output
    --help              Show this help message

EXAMPLES:
    $0                  # Install hooks
    $0 --install        # Install hooks
    $0 --uninstall      # Remove hooks
    $0 --verbose        # Install with verbose output
EOF
}

log() {
    if [[ "$VERBOSE" == "true" ]]; then
        echo -e "${BLUE}[INFO]${NC} $1" >&2
    fi
}

error() {
    echo -e "${RED}[ERROR]${NC} $1" >&2
}

warn() {
    echo -e "${YELLOW}[WARN]${NC} $1" >&2
}

success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1" >&2
}

# Parse command line arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        --install)
            ACTION="install"
            shift
            ;;
        --uninstall)
            ACTION="uninstall"
            shift
            ;;
        --verbose)
            VERBOSE=true
            shift
            ;;
        --help)
            show_help
            exit 0
            ;;
        *)
            error "Unknown option: $1"
            show_help
            exit 1
            ;;
    esac
done

cd "$PROJECT_ROOT"

# Function to check if we're in a git repository
check_git_repo() {
    if [[ ! -d ".git" ]]; then
        error "Not a git repository. Initialize git first with: git init"
        exit 1
    fi

    if [[ ! -d "$GIT_HOOKS_DIR" ]]; then
        mkdir -p "$GIT_HOOKS_DIR"
    fi
}

# Function to create pre-commit hook
create_pre_commit_hook() {
    log "Creating pre-commit hook..."

    local hook_file="$GIT_HOOKS_DIR/pre-commit"

    cat > "$hook_file" << 'EOF'
#!/bin/bash

# Pre-commit hook for documentation updates
# Auto-generated by tools/setup-doc-hooks.sh

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

echo -e "${BLUE}[HOOK]${NC} Running documentation checks..."

# Get the project root
PROJECT_ROOT="$(git rev-parse --show-toplevel)"

# Check if documentation tools exist
if [[ ! -f "$PROJECT_ROOT/tools/verify-docs.sh" ]]; then
    echo -e "${YELLOW}[WARN]${NC} Documentation verification tool not found, skipping checks"
    exit 0
fi

# Run documentation verification
echo -e "${BLUE}[HOOK]${NC} Verifying documentation..."
if ! "$PROJECT_ROOT/tools/verify-docs.sh" --format json > /tmp/doc-check.json; then
    echo -e "${RED}[ERROR]${NC} Documentation verification failed"
    echo "Run './tools/verify-docs.sh' to see details"
    exit 1
fi

# Check for critical issues
critical_issues=$(python3 -c "
import json
import sys
try:
    with open('/tmp/doc-check.json') as f:
        data = json.load(f)
    total = data['summary']['missing_files'] + data['summary']['broken_links']
    print(total)
except:
    print('0')
")

if [[ $critical_issues -gt 0 ]]; then
    echo -e "${RED}[ERROR]${NC} Found $critical_issues critical documentation issues"
    echo "Run './tools/verify-docs.sh --fix' to attempt automatic fixes"
    echo "Or use 'git commit --no-verify' to skip this check"
    exit 1
fi

# Update CLAUDE.md if tools exist
if [[ -f "$PROJECT_ROOT/tools/update-claude-md.sh" ]]; then
    echo -e "${BLUE}[HOOK]${NC} Updating CLAUDE.md..."
    if "$PROJECT_ROOT/tools/update-claude-md.sh" --dry-run | grep -q "would be made"; then
        echo -e "${YELLOW}[WARN]${NC} CLAUDE.md would be updated. Run './tools/update-claude-md.sh' manually."
    fi
fi

# Check for vestigial code if requested
if [[ "${DOC_HOOK_CHECK_VESTIGIAL:-false}" == "true" ]] && [[ -f "$PROJECT_ROOT/tools/check-vestigial.sh" ]]; then
    echo -e "${BLUE}[HOOK]${NC} Checking for vestigial code..."
    if ! "$PROJECT_ROOT/tools/check-vestigial.sh" --format json > /tmp/vestigial-check.json; then
        echo -e "${YELLOW}[WARN]${NC} Vestigial code check failed, continuing..."
    else
        vestigial_count=$(python3 -c "
import json
try:
    with open('/tmp/vestigial-check.json') as f:
        data = json.load(f)
    total = data['summary']['unused_files'] + data['summary']['unused_functions']
    print(total)
except:
    print('0')
")

        if [[ $vestigial_count -gt 10 ]]; then
            echo -e "${YELLOW}[WARN]${NC} Found $vestigial_count potentially unused code items"
            echo "Consider running './tools/check-vestigial.sh' to review"
        fi
    fi
fi

# Cleanup temp files
rm -f /tmp/doc-check.json /tmp/vestigial-check.json

echo -e "${GREEN}[HOOK]${NC} Documentation checks passed"
EOF

    chmod +x "$hook_file"
    success "Pre-commit hook created at $hook_file"
}

# Function to create commit-msg hook
create_commit_msg_hook() {
    log "Creating commit-msg hook..."

    local hook_file="$GIT_HOOKS_DIR/commit-msg"

    cat > "$hook_file" << 'EOF'
#!/bin/bash

# Commit-msg hook for documentation updates
# Auto-generated by tools/setup-doc-hooks.sh

set -e

COMMIT_MSG_FILE="$1"
PROJECT_ROOT="$(git rev-parse --show-toplevel)"

# Check if this is a documentation-related commit
if grep -qiE "(docs?|readme|claude\.md|documentation)" "$COMMIT_MSG_FILE"; then
    # For documentation commits, suggest running verification
    echo "[HOOK] Documentation commit detected"
    echo "[HOOK] Consider running: ./tools/verify-docs.sh"
fi

# Check for specific file patterns that should trigger doc updates
staged_files=$(git diff --cached --name-only)

should_update_docs=false

# Check for changes that should trigger documentation updates
for file in $staged_files; do
    case "$file" in
        package.json|composer.json|requirements.txt|Cargo.toml|go.mod)
            should_update_docs=true
            break
            ;;
        src/*|lib/*|app/*)
            # Only suggest for significant source changes
            if [[ $(git diff --cached --numstat "$file" | awk '{print $1 + $2}') -gt 50 ]]; then
                should_update_docs=true
                break
            fi
            ;;
        tools/*)
            should_update_docs=true
            break
            ;;
    esac
done

if [[ "$should_update_docs" == "true" ]]; then
    echo "[HOOK] Significant changes detected that may require documentation updates"
    echo "[HOOK] Consider running: ./tools/update-claude-md.sh"
fi
EOF

    chmod +x "$hook_file"
    success "Commit-msg hook created at $hook_file"
}

# Function to create post-commit hook
create_post_commit_hook() {
    log "Creating post-commit hook..."

    local hook_file="$GIT_HOOKS_DIR/post-commit"

    cat > "$hook_file" << 'EOF'
#!/bin/bash

# Post-commit hook for documentation updates
# Auto-generated by tools/setup-doc-hooks.sh

PROJECT_ROOT="$(git rev-parse --show-toplevel)"

# Only run on main/master branch to avoid cluttering feature branches
current_branch=$(git rev-parse --abbrev-ref HEAD)
if [[ "$current_branch" != "main" ]] && [[ "$current_branch" != "master" ]]; then
    exit 0
fi

# Check if we have the tools available
if [[ ! -f "$PROJECT_ROOT/tools/verify-docs.sh" ]]; then
    exit 0
fi

# Run a quick documentation check in the background
echo "[HOOK] Running post-commit documentation check..."
(
    cd "$PROJECT_ROOT"
    ./tools/verify-docs.sh --format json > /tmp/post-commit-doc-check.json 2>/dev/null || true

    # Check for issues and log them
    if [[ -f /tmp/post-commit-doc-check.json ]]; then
        issues=$(python3 -c "
import json
try:
    with open('/tmp/post-commit-doc-check.json') as f:
        data = json.load(f)
    total = sum(data['summary'].values())
    if total > 0:
        print(f'Found {total} documentation issues')
        print('Run ./tools/verify-docs.sh for details')
except:
    pass
" 2>/dev/null || true)

        if [[ -n "$issues" ]]; then
            echo "[HOOK] $issues"
        fi

        rm -f /tmp/post-commit-doc-check.json
    fi
) &

# Don't wait for the background process
disown
EOF

    chmod +x "$hook_file"
    success "Post-commit hook created at $hook_file"
}

# Function to create pre-push hook
create_pre_push_hook() {
    log "Creating pre-push hook..."

    local hook_file="$GIT_HOOKS_DIR/pre-push"

    cat > "$hook_file" << 'EOF'
#!/bin/bash

# Pre-push hook for documentation updates
# Auto-generated by tools/setup-doc-hooks.sh

set -e

PROJECT_ROOT="$(git rev-parse --show-toplevel)"

echo "[HOOK] Running pre-push documentation verification..."

# Check if documentation tools exist
if [[ ! -f "$PROJECT_ROOT/tools/verify-docs.sh" ]]; then
    echo "[HOOK] Documentation verification tool not found, skipping checks"
    exit 0
fi

# Run comprehensive documentation check
if ! "$PROJECT_ROOT/tools/verify-docs.sh" --format json > /tmp/pre-push-doc-check.json; then
    echo "[ERROR] Documentation verification failed before push"
    echo "Run './tools/verify-docs.sh --fix' to attempt fixes"
    echo "Or use 'git push --no-verify' to skip this check"
    exit 1
fi

# Check for any critical issues
critical_issues=$(python3 -c "
import json
try:
    with open('/tmp/pre-push-doc-check.json') as f:
        data = json.load(f)
    total = data['summary']['missing_files'] + data['summary']['broken_links']
    print(total)
except:
    print('0')
")

if [[ $critical_issues -gt 0 ]]; then
    echo "[ERROR] Found $critical_issues critical documentation issues before push"
    echo "Run './tools/verify-docs.sh' to see details"
    echo "Fix issues or use 'git push --no-verify' to skip this check"
    exit 1
fi

# Cleanup
rm -f /tmp/pre-push-doc-check.json

echo "[HOOK] Documentation verification passed"
EOF

    chmod +x "$hook_file"
    success "Pre-push hook created at $hook_file"
}

# Function to install all hooks
install_hooks() {
    log "Installing documentation hooks..."

    check_git_repo

    # Backup existing hooks
    local backup_dir="$GIT_HOOKS_DIR/backup-$(date +%Y%m%d_%H%M%S)"
    if ls "$GIT_HOOKS_DIR"/* >/dev/null 2>&1; then
        mkdir -p "$backup_dir"
        cp "$GIT_HOOKS_DIR"/* "$backup_dir"/ 2>/dev/null || true
        log "Existing hooks backed up to $backup_dir"
    fi

    # Create hooks
    create_pre_commit_hook
    create_commit_msg_hook
    create_post_commit_hook
    create_pre_push_hook

    # Create configuration file
    cat > "$PROJECT_ROOT/.git/hooks/doc-hooks.conf" << EOF
# Documentation hooks configuration
# Generated on: $(date)

# Enable vestigial code checking in pre-commit hook
DOC_HOOK_CHECK_VESTIGIAL=false

# Minimum file change threshold for doc update suggestions
DOC_HOOK_CHANGE_THRESHOLD=50

# Skip hooks for emergency commits
DOC_HOOK_EMERGENCY_BYPASS=false
EOF

    success "All documentation hooks installed successfully!"
    echo ""
    echo "Configuration:"
    echo "- Pre-commit: Verifies documentation and checks for critical issues"
    echo "- Commit-msg: Suggests doc updates for significant changes"
    echo "- Post-commit: Runs background documentation check"
    echo "- Pre-push: Comprehensive documentation verification"
    echo ""
    echo "To customize behavior, edit: .git/hooks/doc-hooks.conf"
    echo "To bypass hooks temporarily: git commit --no-verify"
}

# Function to uninstall hooks
uninstall_hooks() {
    log "Uninstalling documentation hooks..."

    local hooks=("pre-commit" "commit-msg" "post-commit" "pre-push")
    local removed_count=0

    for hook in "${hooks[@]}"; do
        local hook_file="$GIT_HOOKS_DIR/$hook"
        if [[ -f "$hook_file" ]] && grep -q "Auto-generated by tools/setup-doc-hooks.sh" "$hook_file"; then
            rm "$hook_file"
            log "Removed $hook hook"
            ((removed_count++))
        fi
    done

    # Remove configuration file
    if [[ -f "$GIT_HOOKS_DIR/doc-hooks.conf" ]]; then
        rm "$GIT_HOOKS_DIR/doc-hooks.conf"
        log "Removed configuration file"
    fi

    if [[ $removed_count -gt 0 ]]; then
        success "Removed $removed_count documentation hooks"
    else
        warn "No documentation hooks found to remove"
    fi
}

# Function to show current hook status
show_status() {
    log "Checking documentation hooks status..."

    if [[ ! -d "$GIT_HOOKS_DIR" ]]; then
        warn "Git hooks directory not found"
        return
    fi

    local hooks=("pre-commit" "commit-msg" "post-commit" "pre-push")
    local installed_hooks=()

    echo "Documentation Hooks Status:"
    echo "=========================="

    for hook in "${hooks[@]}"; do
        local hook_file="$GIT_HOOKS_DIR/$hook"
        if [[ -f "$hook_file" ]] && grep -q "Auto-generated by tools/setup-doc-hooks.sh" "$hook_file" 2>/dev/null; then
            echo "✓ $hook (installed)"
            installed_hooks+=("$hook")
        else
            echo "✗ $hook (not installed)"
        fi
    done

    echo ""

    if [[ ${#installed_hooks[@]} -gt 0 ]]; then
        echo "Installed hooks: ${installed_hooks[*]}"
        if [[ -f "$GIT_HOOKS_DIR/doc-hooks.conf" ]]; then
            echo "Configuration: .git/hooks/doc-hooks.conf"
        fi
    else
        echo "No documentation hooks installed"
    fi
}

# Main execution
main() {
    log "Starting documentation hooks setup..."
    log "Action: $ACTION"
    log "Project root: $PROJECT_ROOT"

    case "$ACTION" in
        install)
            install_hooks
            ;;
        uninstall)
            uninstall_hooks
            ;;
        status)
            show_status
            ;;
        *)
            error "Unknown action: $ACTION"
            show_help
            exit 1
            ;;
    esac
}

# Add status action for completeness
if [[ "${1:-}" == "--status" ]]; then
    ACTION="status"
    shift
fi

# Run main function
main "$@"