#!/usr/bin/env bash
# Integration Tests - Rollback and Recovery Functionality
# Tests backup, rollback, and system recovery workflows
set -euo pipefail

# Source test framework
source "$(dirname "${BASH_SOURCE[0]}")/../test-framework.sh"

# Test configuration
readonly SCRIPT_UNDER_TEST="$PROJECT_ROOT/bootstrap_machine_rites.sh"
readonly MOCK_ENV="$(setup_mock_environment "rollback_integration")"

# Test setup
setup_rollback_tests() {
    export HOME="$MOCK_ENV/home"
    export BACKUP_DIR="$MOCK_ENV/backups"
    export CHEZMOI_SRC="$MOCK_ENV/chezmoi"

    mkdir -p "$HOME" "$BACKUP_DIR" "$CHEZMOI_SRC"
    mkdir -p "$HOME/.config"
    mkdir -p "$HOME/.bashrc.d"
    mkdir -p "$HOME/.local/bin"

    # Create initial system state
    create_initial_system_state

    log_debug "Setup rollback tests environment in: $MOCK_ENV"
}

# Test teardown
cleanup_rollback_tests() {
    cleanup_mock_environment "$MOCK_ENV"
}

# Create initial system state for testing
create_initial_system_state() {
    # Create initial dotfiles
    cat > "$HOME/.bashrc" << 'EOF'
# Original bashrc
export PATH="$HOME/.local/bin:$PATH"
alias ll='ls -la'
EOF

    cat > "$HOME/.gitconfig" << 'EOF'
[user]
    name = Original User
    email = original@example.com
[core]
    editor = vim
EOF

    cat > "$HOME/.vimrc" << 'EOF'
" Original vimrc
set number
set tabstop=4
EOF

    # Create bashrc.d files
    echo '# Original ssh config' > "$HOME/.bashrc.d/10-ssh.sh"
    echo '# Original env config' > "$HOME/.bashrc.d/20-env.sh"
}

# Integration Tests for Rollback Functionality

test_backup_creation_workflow() {
    # Test complete backup creation workflow
    local test_script="$MOCK_ENV/backup_workflow_test.sh"
    cat > "$test_script" << 'EOF'
#!/bin/bash

create_comprehensive_backup() {
    local backup_dir="$1"
    local timestamp=$(date +%Y%m%d_%H%M%S)
    local backup_path="$backup_dir/dotfiles-backup-$timestamp"

    echo "Creating comprehensive backup at: $backup_path"
    mkdir -p "$backup_path"

    # Define files to backup
    local backup_files=(
        ".bashrc"
        ".gitconfig"
        ".vimrc"
        ".bashrc.d"
        ".config/chezmoi"
        ".gnupg"
        ".ssh"
    )

    # Create backup manifest
    cat > "$backup_path/MANIFEST" << MANIFEST
# Backup Manifest
# Created: $(date -Iso8601)
# Hostname: $(hostname)
# User: $(whoami)
# Backup Path: $backup_path

FILES_BACKED_UP:
MANIFEST

    # Backup each file/directory
    for item in "${backup_files[@]}"; do
        local source_path="$HOME/$item"

        if [[ -e "$source_path" ]]; then
            echo "Backing up: $item"
            cp -r "$source_path" "$backup_path/" 2>/dev/null || true
            echo "$item" >> "$backup_path/MANIFEST"
        fi
    done

    # Create restore script
    create_restore_script "$backup_path"

    # Create backup metadata
    create_backup_metadata "$backup_path"

    echo "$backup_path"
}

create_restore_script() {
    local backup_path="$1"

    cat > "$backup_path/restore.sh" << 'RESTORE'
#!/bin/bash
# Automated restore script
# Generated by machine-rites backup system

set -euo pipefail

BACKUP_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
TIMESTAMP=$(date +%Y%m%d_%H%M%S)

echo "=== machine-rites Restore ==="
echo "Backup directory: $BACKUP_DIR"
echo "Restore timestamp: $TIMESTAMP"
echo ""

# Confirm restore
if [[ "${FORCE_RESTORE:-}" != "true" ]]; then
    read -p "This will overwrite current dotfiles. Continue? [y/N] " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        echo "Restore cancelled."
        exit 0
    fi
fi

# Create pre-restore backup
echo "Creating pre-restore backup..."
PRE_RESTORE_DIR="$HOME/pre-restore-backup-$TIMESTAMP"
mkdir -p "$PRE_RESTORE_DIR"

# Read manifest and restore files
echo "Restoring files from manifest..."
while IFS= read -r file; do
    # Skip comments and empty lines
    [[ "$file" =~ ^#.*$ ]] && continue
    [[ -z "$file" ]] && continue
    [[ "$file" == "FILES_BACKED_UP:" ]] && continue

    echo "Restoring: $file"

    # Backup current version if exists
    if [[ -e "$HOME/$file" ]]; then
        cp -r "$HOME/$file" "$PRE_RESTORE_DIR/" 2>/dev/null || true
    fi

    # Restore from backup
    if [[ -e "$BACKUP_DIR/$file" ]]; then
        # Create parent directory if needed
        mkdir -p "$(dirname "$HOME/$file")"

        # Copy file/directory
        cp -r "$BACKUP_DIR/$file" "$HOME/$file"
        echo "  ✓ Restored: $file"
    else
        echo "  ⚠ Not found in backup: $file"
    fi
done < "$BACKUP_DIR/MANIFEST"

echo ""
echo "Restore completed successfully!"
echo "Pre-restore backup saved to: $PRE_RESTORE_DIR"
echo ""
echo "To verify the restore, check your dotfiles:"
echo "  ls -la ~/"
echo "  source ~/.bashrc"
RESTORE

    chmod +x "$backup_path/restore.sh"
}

create_backup_metadata() {
    local backup_path="$1"

    cat > "$backup_path/metadata.json" << METADATA
{
    "backup_version": "1.0",
    "created_at": "$(date -Iso8601)",
    "hostname": "$(hostname)",
    "username": "$(whoami)",
    "os": "$(uname -s)",
    "arch": "$(uname -m)",
    "backup_size_bytes": $(du -sb "$backup_path" | cut -f1),
    "file_count": $(find "$backup_path" -type f | wc -l),
    "tools": {
        "bash_version": "${BASH_VERSION}",
        "chezmoi_version": "$(command -v chezmoi >/dev/null && chezmoi --version || echo 'not installed')"
    }
}
METADATA
}

verify_backup_integrity() {
    local backup_path="$1"

    echo "Verifying backup integrity..."

    # Check backup directory exists
    [[ -d "$backup_path" ]] || return 1

    # Check essential files exist
    [[ -f "$backup_path/MANIFEST" ]] || return 1
    [[ -f "$backup_path/restore.sh" ]] || return 1
    [[ -x "$backup_path/restore.sh" ]] || return 1
    [[ -f "$backup_path/metadata.json" ]] || return 1

    # Verify manifest contains expected entries
    if ! grep -q "FILES_BACKED_UP:" "$backup_path/MANIFEST"; then
        return 1
    fi

    # Check at least some files were backed up
    local file_count
    file_count=$(grep -v "^#" "$backup_path/MANIFEST" | grep -v "FILES_BACKED_UP:" | grep -v "^$" | wc -l)
    [[ $file_count -gt 0 ]] || return 1

    echo "Backup integrity verified"
    return 0
}

# Test backup creation
backup_path=$(create_comprehensive_backup "$BACKUP_DIR")
[[ -n "$backup_path" ]] || exit 1

# Test backup verification
verify_backup_integrity "$backup_path" || exit 1

echo "Backup workflow test completed successfully"
echo "Backup created at: $backup_path"
EOF

    assert_command_succeeds "bash '$test_script'" "backup creation workflow works"
}

test_selective_restore_functionality() {
    # Test selective file restore capabilities
    local test_script="$MOCK_ENV/selective_restore_test.sh"
    cat > "$test_script" << 'EOF'
#!/bin/bash

create_selective_restore_script() {
    local backup_path="$1"

    cat > "$backup_path/selective_restore.sh" << 'SELECTIVE'
#!/bin/bash
# Selective restore script

set -euo pipefail

BACKUP_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

show_available_files() {
    echo "Available files for restore:"
    echo ""

    local index=1
    while IFS= read -r file; do
        [[ "$file" =~ ^#.*$ ]] && continue
        [[ -z "$file" ]] && continue
        [[ "$file" == "FILES_BACKED_UP:" ]] && continue

        if [[ -e "$BACKUP_DIR/$file" ]]; then
            printf "%2d) %s\n" $index "$file"
            ((index++))
        fi
    done < "$BACKUP_DIR/MANIFEST"
}

restore_specific_file() {
    local file="$1"
    local backup_original="${2:-true}"

    echo "Restoring: $file"

    # Create backup of current version if requested
    if [[ "$backup_original" == "true" ]] && [[ -e "$HOME/$file" ]]; then
        local backup_name="${file##*/}.backup.$(date +%Y%m%d_%H%M%S)"
        cp -r "$HOME/$file" "$HOME/$backup_name"
        echo "  Original backed up as: $backup_name"
    fi

    # Restore file
    if [[ -e "$BACKUP_DIR/$file" ]]; then
        mkdir -p "$(dirname "$HOME/$file")"
        cp -r "$BACKUP_DIR/$file" "$HOME/$file"
        echo "  ✓ Restored: $file"
        return 0
    else
        echo "  ✗ File not found in backup: $file"
        return 1
    fi
}

# Command line interface
case "${1:-menu}" in
    "list")
        show_available_files
        ;;
    "restore")
        if [[ -n "${2:-}" ]]; then
            restore_specific_file "$2" "${3:-true}"
        else
            echo "Usage: $0 restore <file> [backup_original]"
            exit 1
        fi
        ;;
    "menu"|*)
        show_available_files
        echo ""
        echo "Usage:"
        echo "  $0 list                    - Show available files"
        echo "  $0 restore <file>          - Restore specific file"
        echo "  $0 restore <file> false    - Restore without backing up current"
        ;;
esac
SELECTIVE

    chmod +x "$backup_path/selective_restore.sh"
}

test_selective_restore() {
    local backup_path="$1"

    # Create selective restore script
    create_selective_restore_script "$backup_path"

    # Test listing available files
    local available_files
    available_files=$("$backup_path/selective_restore.sh" list 2>&1)
    echo "$available_files" | grep -q ".bashrc" || return 1

    # Modify current .bashrc
    echo "# Modified bashrc" > "$HOME/.bashrc"

    # Test selective restore of .bashrc
    "$backup_path/selective_restore.sh" restore ".bashrc" || return 1

    # Verify restore
    grep -q "Original bashrc" "$HOME/.bashrc" || return 1

    # Verify backup was created
    find "$HOME" -name ".bashrc.backup.*" | grep -q "." || return 1

    return 0
}

# Create test backup
backup_path=$(create_comprehensive_backup "$BACKUP_DIR")

# Test selective restore
test_selective_restore "$backup_path" || exit 1

echo "Selective restore test completed successfully"
EOF

    assert_command_succeeds "bash '$test_script'" "selective restore functionality works"
}

test_rollback_verification() {
    # Test rollback verification and validation
    local test_script="$MOCK_ENV/rollback_verification_test.sh"
    cat > "$test_script" << 'EOF'
#!/bin/bash

verify_rollback_success() {
    local expected_files=("$@")
    local failed_files=()

    echo "Verifying rollback success..."

    for file in "${expected_files[@]}"; do
        if [[ ! -e "$HOME/$file" ]]; then
            failed_files+=("$file")
            echo "  ✗ Missing: $file"
        else
            echo "  ✓ Found: $file"
        fi
    done

    if [[ ${#failed_files[@]} -eq 0 ]]; then
        echo "Rollback verification: PASSED"
        return 0
    else
        echo "Rollback verification: FAILED"
        echo "Missing files: ${failed_files[*]}"
        return 1
    fi
}

check_file_contents() {
    local file="$1"
    local expected_pattern="$2"

    if [[ -f "$HOME/$file" ]]; then
        if grep -q "$expected_pattern" "$HOME/$file"; then
            echo "  ✓ Content verified: $file"
            return 0
        else
            echo "  ✗ Content mismatch: $file"
            return 1
        fi
    else
        echo "  ✗ File not found: $file"
        return 1
    fi
}

test_configuration_consistency() {
    echo "Testing configuration consistency..."

    # Test .bashrc content
    check_file_contents ".bashrc" "Original bashrc" || return 1

    # Test .gitconfig content
    check_file_contents ".gitconfig" "Original User" || return 1

    # Test .vimrc content
    check_file_contents ".vimrc" "Original vimrc" || return 1

    echo "Configuration consistency: PASSED"
    return 0
}

test_permissions_and_ownership() {
    echo "Testing file permissions and ownership..."

    local files=(".bashrc" ".gitconfig" ".vimrc")

    for file in "${files[@]}"; do
        if [[ -f "$HOME/$file" ]]; then
            # Check file is readable by user
            if [[ -r "$HOME/$file" ]]; then
                echo "  ✓ Readable: $file"
            else
                echo "  ✗ Not readable: $file"
                return 1
            fi

            # Check file ownership (simplified check)
            local owner
            owner=$(stat -c "%U" "$HOME/$file" 2>/dev/null || echo "unknown")
            echo "  ℹ Owner: $file -> $owner"
        fi
    done

    echo "Permissions and ownership: PASSED"
    return 0
}

run_post_rollback_tests() {
    echo "Running post-rollback tests..."

    # Test that bashrc can be sourced without errors
    if bash -c "source $HOME/.bashrc" 2>/dev/null; then
        echo "  ✓ .bashrc sources successfully"
    else
        echo "  ✗ .bashrc has syntax errors"
        return 1
    fi

    # Test git configuration
    if command -v git >/dev/null 2>&1; then
        export HOME="$HOME"
        if git config user.name >/dev/null 2>&1; then
            echo "  ✓ Git configuration valid"
        else
            echo "  ⚠ Git configuration incomplete"
        fi
    fi

    echo "Post-rollback tests: PASSED"
    return 0
}

# Run verification tests
verify_rollback_success ".bashrc" ".gitconfig" ".vimrc" || exit 1
test_configuration_consistency || exit 1
test_permissions_and_ownership || exit 1
run_post_rollback_tests || exit 1

echo "Rollback verification completed successfully"
EOF

    assert_command_succeeds "bash '$test_script'" "rollback verification works"
}

test_automated_rollback_triggers() {
    # Test automated rollback triggers and conditions
    local test_script="$MOCK_ENV/rollback_triggers_test.sh"
    cat > "$test_script" << 'EOF'
#!/bin/bash

detect_system_corruption() {
    local corruption_indicators=()

    echo "Detecting system corruption..."

    # Check for missing critical files
    local critical_files=(".bashrc" ".gitconfig")
    for file in "${critical_files[@]}"; do
        if [[ ! -f "$HOME/$file" ]]; then
            corruption_indicators+=("missing_$file")
        fi
    done

    # Check for malformed configurations
    if [[ -f "$HOME/.bashrc" ]]; then
        if ! bash -n "$HOME/.bashrc" 2>/dev/null; then
            corruption_indicators+=("malformed_bashrc")
        fi
    fi

    # Check for empty critical files
    for file in "${critical_files[@]}"; do
        if [[ -f "$HOME/$file" ]] && [[ ! -s "$HOME/$file" ]]; then
            corruption_indicators+=("empty_$file")
        fi
    done

    if [[ ${#corruption_indicators[@]} -gt 0 ]]; then
        echo "Corruption detected: ${corruption_indicators[*]}"
        return 1
    else
        echo "No corruption detected"
        return 0
    fi
}

auto_rollback_on_failure() {
    local backup_dir="$1"
    local latest_backup

    echo "Checking for rollback conditions..."

    if ! detect_system_corruption; then
        echo "System corruption detected, initiating auto-rollback..."

        # Find latest backup
        latest_backup=$(find "$backup_dir" -maxdepth 1 -name "dotfiles-backup-*" -type d | sort | tail -1)

        if [[ -n "$latest_backup" ]] && [[ -d "$latest_backup" ]]; then
            echo "Found backup for rollback: $latest_backup"

            # Execute rollback
            if [[ -x "$latest_backup/restore.sh" ]]; then
                echo "Executing automatic rollback..."
                (cd "$latest_backup" && FORCE_RESTORE=true ./restore.sh)
                return $?
            else
                echo "Restore script not found or not executable"
                return 1
            fi
        else
            echo "No backup found for rollback"
            return 1
        fi
    else
        echo "System is healthy, no rollback needed"
        return 0
    fi
}

simulate_corruption_scenarios() {
    echo "Testing corruption detection scenarios..."

    # Scenario 1: Missing .bashrc
    mv "$HOME/.bashrc" "$HOME/.bashrc.hidden"
    if detect_system_corruption; then
        echo "  ✗ Failed to detect missing .bashrc"
        mv "$HOME/.bashrc.hidden" "$HOME/.bashrc"
        return 1
    else
        echo "  ✓ Detected missing .bashrc"
        mv "$HOME/.bashrc.hidden" "$HOME/.bashrc"
    fi

    # Scenario 2: Malformed .bashrc
    local original_bashrc
    original_bashrc=$(cat "$HOME/.bashrc")
    echo 'if [[ missing bracket' > "$HOME/.bashrc"
    if detect_system_corruption; then
        echo "  ✗ Failed to detect malformed .bashrc"
        echo "$original_bashrc" > "$HOME/.bashrc"
        return 1
    else
        echo "  ✓ Detected malformed .bashrc"
        echo "$original_bashrc" > "$HOME/.bashrc"
    fi

    # Scenario 3: Empty .gitconfig
    local original_gitconfig
    original_gitconfig=$(cat "$HOME/.gitconfig")
    > "$HOME/.gitconfig"  # Make file empty
    if detect_system_corruption; then
        echo "  ✗ Failed to detect empty .gitconfig"
        echo "$original_gitconfig" > "$HOME/.gitconfig"
        return 1
    else
        echo "  ✓ Detected empty .gitconfig"
        echo "$original_gitconfig" > "$HOME/.gitconfig"
    fi

    echo "Corruption scenario testing: PASSED"
    return 0
}

# Create a backup for testing
backup_path=$(create_comprehensive_backup "$BACKUP_DIR")

# Test corruption detection scenarios
simulate_corruption_scenarios || exit 1

# Test auto-rollback mechanism (simulate corruption)
echo 'syntax error in bashrc [' > "$HOME/.bashrc"
auto_rollback_on_failure "$BACKUP_DIR" || exit 1

# Verify rollback worked
if grep -q "Original bashrc" "$HOME/.bashrc"; then
    echo "Auto-rollback test: PASSED"
else
    echo "Auto-rollback test: FAILED"
    exit 1
fi

echo "Automated rollback triggers test completed successfully"
EOF

    assert_command_succeeds "bash '$test_script'" "automated rollback triggers work"
}

test_backup_retention_policies() {
    # Test backup retention and cleanup policies
    local test_script="$MOCK_ENV/retention_policies_test.sh"
    cat > "$test_script" << 'EOF'
#!/bin/bash

create_multiple_backups() {
    local backup_dir="$1"
    local count="$2"

    echo "Creating $count test backups..."

    for ((i=1; i<=count; i++)); do
        local timestamp=$(date -d "$i days ago" +%Y%m%d_%H%M%S)
        local backup_path="$backup_dir/dotfiles-backup-$timestamp"

        mkdir -p "$backup_path"
        echo "Backup $i" > "$backup_path/test_file.txt"
        echo "# Backup created $(date -d "$i days ago")" > "$backup_path/MANIFEST"

        # Simulate different backup sizes
        local size=$((i * 1024))
        dd if=/dev/zero of="$backup_path/size_file.dat" bs=1 count=$size 2>/dev/null
    done

    echo "Created $count backups"
}

apply_retention_policy() {
    local backup_dir="$1"
    local max_backups="${2:-5}"
    local max_age_days="${3:-30}"

    echo "Applying retention policy (max: $max_backups, age: $max_age_days days)..."

    # Find all backups
    local backups=($(find "$backup_dir" -maxdepth 1 -name "dotfiles-backup-*" -type d | sort))
    local total_backups=${#backups[@]}

    echo "Found $total_backups backups"

    # Remove old backups by age
    local removed_by_age=0
    for backup in "${backups[@]}"; do
        local backup_name=$(basename "$backup")
        local backup_date=$(echo "$backup_name" | sed 's/dotfiles-backup-//' | sed 's/_.*$//')

        # Check if backup is older than max_age_days
        if [[ $(date -d "$backup_date" +%s) -lt $(date -d "$max_age_days days ago" +%s) ]]; then
            echo "Removing old backup: $backup_name"
            rm -rf "$backup"
            ((removed_by_age++))
        fi
    done

    # Refresh backup list after age-based removal
    backups=($(find "$backup_dir" -maxdepth 1 -name "dotfiles-backup-*" -type d | sort))
    total_backups=${#backups[@]}

    # Remove excess backups by count
    local removed_by_count=0
    if [[ $total_backups -gt $max_backups ]]; then
        local excess=$((total_backups - max_backups))

        for ((i=0; i<excess; i++)); do
            echo "Removing excess backup: $(basename "${backups[$i]}")"
            rm -rf "${backups[$i]}"
            ((removed_by_count++))
        done
    fi

    echo "Removed $removed_by_age backups by age, $removed_by_count by count"

    # Show remaining backups
    local remaining=($(find "$backup_dir" -maxdepth 1 -name "dotfiles-backup-*" -type d | sort))
    echo "Remaining backups: ${#remaining[@]}"

    return 0
}

calculate_backup_sizes() {
    local backup_dir="$1"

    echo "Calculating backup sizes..."

    local backups=($(find "$backup_dir" -maxdepth 1 -name "dotfiles-backup-*" -type d | sort))
    local total_size=0

    for backup in "${backups[@]}"; do
        local size=$(du -sb "$backup" 2>/dev/null | cut -f1)
        local size_mb=$((size / 1024 / 1024))

        echo "  $(basename "$backup"): ${size_mb}MB"
        total_size=$((total_size + size))
    done

    local total_mb=$((total_size / 1024 / 1024))
    echo "Total backup size: ${total_mb}MB"

    return 0
}

test_retention_policy() {
    local backup_dir="$1"

    # Create test backups
    create_multiple_backups "$backup_dir" 10

    # Check initial count
    local initial_count
    initial_count=$(find "$backup_dir" -maxdepth 1 -name "dotfiles-backup-*" -type d | wc -l)
    [[ $initial_count -eq 10 ]] || return 1

    # Apply retention policy (keep max 5 backups, 7 days max age)
    apply_retention_policy "$backup_dir" 5 7

    # Check final count
    local final_count
    final_count=$(find "$backup_dir" -maxdepth 1 -name "dotfiles-backup-*" -type d | wc -l)

    # Should have removed some backups
    [[ $final_count -lt $initial_count ]] || return 1

    # Should not exceed max limit
    [[ $final_count -le 5 ]] || return 1

    echo "Retention policy test: PASSED"
    return 0
}

# Test retention policies
test_retention_policy "$BACKUP_DIR" || exit 1

# Test size calculation
calculate_backup_sizes "$BACKUP_DIR" || exit 1

echo "Backup retention policies test completed successfully"
EOF

    assert_command_succeeds "bash '$test_script'" "backup retention policies work"
}

test_cross_platform_compatibility() {
    # Test rollback functionality across different platforms
    local test_script="$MOCK_ENV/cross_platform_test.sh"
    cat > "$test_script" << 'EOF'
#!/bin/bash

simulate_platform_differences() {
    echo "Testing cross-platform compatibility..."

    # Simulate different OS environments
    test_path_differences || return 1
    test_permission_handling || return 1
    test_line_ending_handling || return 1

    return 0
}

test_path_differences() {
    echo "Testing path handling..."

    # Test various path formats
    local test_paths=(
        "/home/user/.bashrc"
        "/Users/user/.bashrc"
        "C:/Users/user/.bashrc"
        "/mnt/c/Users/user/.bashrc"
    )

    for path in "${test_paths[@]}"; do
        # Normalize path (simplified)
        local normalized_path
        normalized_path=$(echo "$path" | sed 's|\\|/|g' | sed 's|C:|/mnt/c|')
        echo "  $path -> $normalized_path"
    done

    echo "Path handling: PASSED"
    return 0
}

test_permission_handling() {
    echo "Testing permission handling..."

    # Create test file with specific permissions
    local test_file="$HOME/permission_test.txt"
    echo "test content" > "$test_file"
    chmod 644 "$test_file"

    # Verify permissions
    local perms
    perms=$(stat -c "%a" "$test_file" 2>/dev/null || echo "644")

    if [[ "$perms" == "644" ]]; then
        echo "Permission handling: PASSED"
        rm -f "$test_file"
        return 0
    else
        echo "Permission handling: FAILED"
        rm -f "$test_file"
        return 1
    fi
}

test_line_ending_handling() {
    echo "Testing line ending handling..."

    # Create files with different line endings
    local unix_file="$HOME/unix_endings.txt"
    local dos_file="$HOME/dos_endings.txt"

    # Unix line endings (LF)
    printf "line1\nline2\nline3\n" > "$unix_file"

    # DOS line endings (CRLF)
    printf "line1\r\nline2\r\nline3\r\n" > "$dos_file"

    # Test reading both formats
    local unix_lines dos_lines
    unix_lines=$(wc -l < "$unix_file")
    dos_lines=$(wc -l < "$dos_file")

    if [[ $unix_lines -eq 3 ]] && [[ $dos_lines -eq 3 ]]; then
        echo "Line ending handling: PASSED"
        rm -f "$unix_file" "$dos_file"
        return 0
    else
        echo "Line ending handling: FAILED"
        rm -f "$unix_file" "$dos_file"
        return 1
    fi
}

create_portable_backup() {
    local backup_path="$1"

    echo "Creating portable backup format..."

    # Create backup with platform metadata
    cat > "$backup_path/platform_info.json" << PLATFORM
{
    "source_os": "$(uname -s)",
    "source_arch": "$(uname -m)",
    "backup_format_version": "1.0",
    "portable": true,
    "path_separator": "/",
    "line_endings": "unix",
    "encoding": "utf-8"
}
PLATFORM

    # Create platform-specific restore instructions
    cat > "$backup_path/RESTORE_INSTRUCTIONS.txt" << INSTRUCTIONS
Platform-Specific Restore Instructions
=====================================

Linux/macOS:
  ./restore.sh

Windows (WSL):
  bash ./restore.sh

Windows (Git Bash):
  bash ./restore.sh

Windows (PowerShell):
  Use the WSL or Git Bash instructions above.

Notes:
- File permissions may need manual adjustment on Windows
- Path separators are automatically converted
- Line endings are preserved as Unix format (LF)
INSTRUCTIONS

    echo "Portable backup format: CREATED"
    return 0
}

# Test platform compatibility
simulate_platform_differences || exit 1

# Create portable backup
backup_path=$(create_comprehensive_backup "$BACKUP_DIR")
create_portable_backup "$backup_path" || exit 1

echo "Cross-platform compatibility test completed successfully"
EOF

    assert_command_succeeds "bash '$test_script'" "cross-platform compatibility works"
}

# Test execution
main() {
    init_test_framework
    start_test_suite "Rollback_Integration"

    setup_rollback_tests

    run_test "Backup Creation Workflow" test_backup_creation_workflow
    run_test "Selective Restore Functionality" test_selective_restore_functionality
    run_test "Rollback Verification" test_rollback_verification
    run_test "Automated Rollback Triggers" test_automated_rollback_triggers
    run_test "Backup Retention Policies" test_backup_retention_policies
    run_test "Cross-Platform Compatibility" test_cross_platform_compatibility

    cleanup_rollback_tests
    end_test_suite
    finalize_test_framework
}

# Run tests if executed directly
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi